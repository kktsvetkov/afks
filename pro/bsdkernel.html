<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style>
<!--
a{text-decoration: none; color:black}
a:hover{text-decoration:underline; color:#CB0000}
.t{font-size:13px; font-family: Tahoma; text-indent: 24 }
.z{text-indent: 0 }
.s{text-indent: 0; font-size:10px}
-->
</style>
<title>Основни характеристики на UNIX. (първа част)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"/>
</head>

<body>

<table width="100%" cellspacing cellpadding class="t">
  <tr>
    <td><table width="100%" cellspacing class="t">
      <tr>
        <td><table width="100%" cellspacing cellpadding>
          <tr>
            <td class="s" bgcolor="#FFFFFF" width="100%"><a href="javascript:self.print()">[разпечатване]</a></td>
            <td class="s" bgcolor="#FFFFFF" width="0%"><a href="../komentar.html?Основни характеристики на UNIX. (първа част)">[коментар]</a></td>
          </tr>
        </table>
        </td>
      </tr>
      <tr>
        <td class="z" align="center"><b><br>
        Основни характеристики на UNIX. Представяне на
        типично UNIX ядро.<br>
        Част І.</b> Дизайн и имплементация на 4.4BSD<br>
        <a href="../izd/toma_borisov.html"><em>Тома Борисов</em></a></td>
      </tr>
    </table>
    <p><strong>Въведение</strong></p>
    <p>Поради голямата си популярност UNIX е може би
    една от най-интересните теми за обсъждане. Много
    от UNIX SO са free или open source, а това ги прави крайно
    удобни за развитие от страна на голям кръг
    разработчици. Честото клониране при тях е
    обичайно явление.<br>
    Мислех си каква да е първата тема в тази рубрика.
    Имах много възможности; на първо място можеше да
    се пише за Linux. Това до някъде изглежда оправдано.
    Linux е определено най-бързо развиващата се OS сред
    UNIX клонингите. За нея е написано много, така че
    нямаше да е трудно да намеря необходимите
    материали, освен това опитът ми с нея е много
    по-голям отколкото с другите UNIX системи. От друга
    страна именно тази популярност както и факта, че
    Linux е UNIX-like а не 100% UNIX ме възпря да започна с него.
    Трябваше да намеря истински UNIX за когото да пиша.
    Това логично трябваше да бъде или Sun Solaris или BSD.
    Заради скромния ми опит със Solaris и липсата на
    инсталирана версия под ръка факта че се
    разпространява под по-стриктен лиценз, реших да
    не се занимавам с него за сега. Остана разбира се
    BSD. Тя има Open Source варианти, които дават възможност
    да се реализират редица мрежови проекти при това
    на най-високо ниво. Така, че инсталирах FreeBSD 4.2 и
    започнах да е занимавам с него. BSD е един от
    най-разпространените UNIX. На базата на него са
    изградени много OS като FreeBSD, OpenBSD, BSDi, NetBSD, а на
    последно време и не толкова типични UNIX OS като <s>BeOS</s> и
    MacOS X.<br>
    Първата тема ще е за ядрото на BSD. Тук ще се
    занимаваме с някои системни особености и ще се
    даде описание на основните му характеристики.
    Поради обемистия материал този въпрос ще се
    разгледа в няколко статии - четири по мои
    преценки. На някои това може да се стори скучно,
    но целта на материала е да се събере информация
    за същността на операционната система. Имам идея
    да направя подобно проучване и за Linux, като се
    надявам това да послужи за добра база за
    сравнение между UNIX системите.<br>
    Нямам намерение да давам описание относно
    ползването на UNIX като цяло, а ще се концентрирам
    върху оптимизирането им и някои въпроси за
    сигурността. Разбира се ще оценя препоръки към
    темата и дори бих окуражил изпращането на
    материали от ваша страна, които да бъдат
    публикувани в тази рубрика.</p>
    <p><strong>История на UNIX</strong></p>
    <p>Началото на операционната система UNIX се
    поставя от CTSS, обширна система с поделяне по
    време, разработена от Ф. Корбато в Масачузетския
    технологичен институт в началото на 60-те.
    Разбирайки предимствата на
    многопотребителските многозадачни системи GENERAL
    ELECTRIC, AT&amp;T BELL LABS и MIT започват проект въз основата
    на операционната система GE635 наречен MULTICS. Поради
    закъсняване на проекта AT&amp;T изтегля част от
    персонала си към други проекти. През късната
    пролет и ранното лято на 1969 Руд Канадей, Дъг
    Макилрой, Денис Ритчи и Кен Томпсън започват
    обсъждане по въпроса какво може да се спаси от
    идеите на MULTICS. През август Томсън написва
    операционна система, шел, редактор и асемблер,
    отделяйки за всяко по една седмица. Питър Нюман
    нарича новата операционна система UNICS. Не е ясно
    как се е стигнало до UNIX.<br>
    От 1970 до 1972 системата се подобрява и се добавят
    много нов възможности. UNIX остава ограничена само
    до лабораториите на AT&amp;T, докато не я инсталират
    в телефонния отдел в Манхатън. През следващата
    година все нови и нови членове на компютърната
    общност чуват за UNIX и питат за нея. В AT&amp;T се чудят
    какво да правят. Те немогат да включат в бизнеса
    нещо различно от телефония и телеграфия, така че
    решават да дадат UNIX на нормална цена на
    университетските изследователски центрове при
    следните условия: без реклами, без поддръжка, без
    коригиране на грешките и с плащане в аванс. В
    резултат на това общността на потребителите на
    UNIX се увеличава. Използването й расте въпреки
    липсата на поддръжка от страна на AT&amp;T.<br>
    Тъй като системата постоянно се променя версиите
    се именуват според ръководствата за програмисти,
    издавани от Ричи и Томпсън - Първа редакция 1971,
    Втора редакция 1972...<br>
    През октомври 1973 се изготвя Четвърта редакция на
    UNIX. Тъй като системата е леснодостъпна и AT&amp;T не я
    поддържат, потребителите на системата се
    обединяват и започват сами да си помагат, а някои
    от тях се заемат сами да добавят нови функции.
    Университета Бъркли в Калифорния е мястото с
    най-голяма активност в тези разработки.<br>
    В началото на 1978 има големи заявки за
    разработките на Бъркли и те започват да се
    дистрибутират. Първата лента съдържа система
    Паскал за UNIX и текстов редактор <em>ex</em>. Преди края
    на 1978 е пусната втората версия - 2BSD. В това време <em>Interactive
    Systems</em> пуска първата комерсиална версия на UNIX, а
    Whitesmiths - първия клонинг <em>Idris</em>.<br>
    Седма версия (1979) на UNIX е сред най-важните. Тя е
    първата преносима операционна система и съдържа <em>awk,
    make, uucp</em>. Но производителността е по-слаба в
    сравнение с предходната версия. Потребителският
    вариант се появява през 1982 под името 2.8.1BSD.
    Последната версия е 4.4BSD от 1993. BSD вече се поддържа
    от BSDI (след съдебен процес).<br>
    AT&amp;T се опитват да създадат унификация на UNIX
    системите: тяхната System V и BSD версията на Бъркли. В
    резултат на това се получава System V Release 4, която
    комбинира и двете системи. Тя става основа за
    разработената от Sun SunOS, 4.x BSD версиите на която е
    преименувана на Solaris. Освен System V Release 4
    производителите създават още един стандарт
    наречен POSIX, характеризиращ основните черти
    които трябва да носи една UNIX система. Той е
    отворен стандарт и дори WinNT отговаря на някои от
    изискванията. Най-интересният от всички UNIX
    клонове е Linux. Той е създаден от Линус Торвалдс
    през 1991. За историята на Linux сте се спрем подробно
    в други статии.</p>
    <p><strong>Ядрото</strong></p>
    <p>Ядрото е час от системата, което се изпълнява в
    защитен режим и осигурява връзката на
    потребителските програми с прилежащия хардуер
    както и с другите софтуерни съставляващи
    (файлова система, мрежови протоколи). Ядрото
    предоставя също и основните функционалности;
    създава и управлява процесите, предоставя
    функции за достъп до файловата система и
    средствата за комуникация. Тези функции се
    наричат system calls и са достъпни на потребителските
    процеси под формата на библиотечни процедури и
    функции. Тези system calls са единствения интерфейс
    към функционалностите на ядрото. Kernel в
    традиционната терминология на операционните
    системи е малко ядро от софтуер, който предоставя
    само функционалност, необходимата за
    имплементацията на допълнителното софтуерно
    обкръжение. Така например достъп до файлова
    система и мрежовите функции се изпълняват като
    допълнителни услуги.<br>
    4.4BSD ядрото не е разделено на различни процеси,
    както е било в ранните UNIX версии. Ранните kernels са
    малки и при включването на услуги като мрежова
    поддръжка се увелича ват размерите им.
    Съвременната тенденция при OS е да запази малкия
    размер на ядрото като тези услуги са изпълнени
    като отделни приложения. За тази версия обаче е
    бил избран монолитен kernel за производителност и
    лекота при проектиране.</p>
    <p><strong>Организация на ядрото</strong></p>
    <p>Най-голяма част от ядрото е имплементация на
    системните функционалности до които
    приложенията имат достъп през <em>system calls</em>. В 4.4BSD
    кодът е разделен условно на следните части:<ul
    type="square">
      <li>Основна функционалност на ядрото: таймер и
        управление на системния часовник, управление на
        дескриптора и системни процеси;</li>
      <li>Управление на паметта: paging и swapping;</li>
      <li>Основни системни интерфейси: I/O, управление;</li>
      <li>Файлова система: файлове, директории,
        заключване на файл, определяне на пътищата до
        файл, управление на I/O буфера;</li>
      <li>Поддръжка на терминали: драйвери за терминални
        устройства;</li>
      <li>Поддръжка на мрежова комуникация: протоколи и
        основни мрежови функционалности като routing.</li>
    </ul>
    <p>По-голямата част (80.4% или 162 617 реда код) то ядрото
    е машинно независим код и е приложим при различни
    платформи.<br>
    Машинно зависимият код е изолиран от главния
    сорс на ядрото, тоест никоя част от машинно
    независимия код няма зависимост от какъвто и да е
    машинно зависим код. Частите, които са машинно
    зависими са съответно:<ul type="square">
      <li>Стартов процес на ниско ниво;</li>
      <li>Управление на прихващанията и грешките;</li>
      <li>Управление на ниско ниво на изпълнимото
        съдържание на процес;</li>
      <li>Конфигуриране и инициализиране на хардуера;</li>
      <li>Изпълнима поддръжка за I/O.</li>
    </ul>
    <p>Може да се отбележи, че кодът писан на асемблер
    е под 2% от целия, останалата част е писана на C.<br>
    Само малка част от ядрото е предназначена за
    инициализация на системата. Този код е отговорен
    за първоначалното зареждане и за настройките на
    хардуерната и софтуерната сред на ядрото. Някои
    операционни системи (тези с ограничени ресурси)
    игнорират или свалят от паметта кода изпълняващ
    тези функции след като се изпълнят. 4.4BSD не взема
    паметта на тези програми, защото те
    представляват едва 0.5% от общото системно
    натоварване на нормална машина. Освен това
    стартовият код не се намира само на едно място в
    ядрото, а е разпръснат.</p>
    <p><strong>Услугите в ядрото</strong></p>
    <p>Границата между ядрото и потребителските
    програми се налага от защитения режим на
    прилежащия хардуер. Ядрото оперира в отделно
    адресно поле, недостъпно за потребителските
    процеси. Привилегировани операции като
    започването на I/O или изключването на процесора
    са достъпни само за ядрото. Процесите изискват
    услуги от ядрото чрез <em>system calls</em>. Тези заявки са
    механизмът чрез който потребителските процеси
    изискват от ядрото извършване на сложни операции
    като запис върху носител или прости операции
    като връщането на текущото време. Всички заявки
    изглеждат синхронни за приложението. То не се
    изпълнява докато действието свързано с <em>system call</em>
    се изпълнява. Ядрото може да свърши с
    изпълнението на някои операции, свързани с
    заявката и след като се е възстановил от<em> system call</em>.
    Например при заявка за запис ядрото копира
    нужната информация в буфера си, но се
    възстановява преди да е приключил записът от
    буфера на носителя.<br>
    <em>System call</em> обикновено се изпълнява като
    хардуерно прихващане, които променя режима на
    изпълнение на процесора и адресирането на
    паметта. Параметрите, предавани от програмите
    чрез <em>system calls</em> се проверяват от ядрото преди да
    се изпълнят. Такава проверка осигурява цялостта
    на системата. Всички параметри се копират в
    адресното пространство на ядрото, за да се
    гарантира че валидираните параметри не се
    променят в резултат на странични ефекти,
    породени от изпълнението на<em> system call</em>.
    Резултатите от заявките се връщат от кернела във
    вид на хардуерни регистри или чрез копиране на
    техните стойности в оказан от потребителския
    процес адрес. Също както параметрите, кака и
    върнатите адреси и резултати се валидират за да
    се установи тяхната принадлежност към адресното
    пространство на процеса. Ако се установи грешка
    по време на изпълнение на <em>system call</em>, ядрото
    връща код за грешка на потребителя.<br>
    Потребителските приложения и ядрото оперират
    независимо едни от други. 4.4BSD не съхранява I/O
    контролни блокове или друга информация, свързана
    с OS, в потребителското адресно пространство.
    Всеки потребителски процес има собствено
    адресно пространство в което се изпълнява.</p>
    <p><strong>Управление на процесите</strong></p>
    <p>4.4BSD поддържа многозадачна среда. Всяка задача
    или тред от изпълнения се нарича процес.
    Контекста на процес се състои от потребителско
    ниво, включващ съдържанието на неговото адресно
    поле и средата за изпълнение, както и от
    кернелско ниво, което включва параметри на
    планирането, контроли на ресурсите и
    идентификационна информация. Контекста на
    процес включва всичко използвано от ядрото при
    доставяне на необходимите му услуги.
    Потребителят може да изпълнява процес, да
    контролира неговото състояние по време на
    изпълнение и да получава информация за статуса
    по време на изпълнението. На всеки процес се
    присвоява уникална стойност, наречена
    идентификатор на процеса (PID). Тази стойност се
    използва от ядрото за да идентифицира процес
    когато докладва неговото състояние на
    потребителя или от потребителя, когато той
    изпраща <em>system call</em> чрез ядрото към процеса.<br>
    Ядрото създава процес като дупликира контекста
    от друг процес. Новият процес се нарича <em>child process</em>
    на оригинала, който от своя страна се нарича <em>parent
    process</em>. Контекста дуплициран при създаването на
    процес включва както потребителското състояние
    на изпълнение, така и системното положение на
    процеса управляван от ядрото.</p>
    <p align="center"><img src="fig1.gif" width="380" height="94" border="0"></p>
    <p>На горната фигура е показан живота на един
    процес. Процес създава свой <em>child</em> процес чрез <em>fork
    system call</em>. Той връща две стойности - съответно в
    родителският процес връща PID на <em>child</em> процеса,
    а на <em>child</em> процеса връща 0. Отношенията между
    child и parent процес са строго йерархични. Новият
    процес поделя всички ресурси на създалият го
    процес като файлови дескриптори, статус на
    сигналите и разположение в паметта.<br>
    Въпреки това има случаи, когато новият процес не
    е просто копие на родителят, а се зарежда и
    изпълнява друг код. Процес може да препокрие
    своето адресно поле с адресно поле на друга
    програма, като подава на новосъздаденото копие
    набор от параметри, като се използва<em> system call execve</em>.
    Един от параметрите е името на файл във формат,
    разбираем за системата - бинарен изпълним файл
    или файл, който предизвиква изпълнението на
    специфична програма, която интерпретира
    неговото съдържание (скрипт).<br>
    Процес може да бъде терминиран чрез изпълнението
    на <em>exit system call</em>, като при това се изпраща 8-битов
    изходен статус на родителя. Ако процес иска да
    предаде повече от един байт информация с
    родителя си, то той трябва или да премине в режим
    на междупроцесна комуникация или да използва
    файл посредник.<br>
    Процес може да преустанови временно своето
    изпълнение докато някой от неговите <em>child</em>
    процеси не се терминира и не върне своя PID и
    изходен статус, като се използва <em>wait system call</em>.
    Родителски процес може да се настрои да бъде
    информиран, когато някой от неговите подпроцеси
    е терминиран ненормално или излезе. Това се
    постига чрез <em>wait4 system cal</em>l като по този начин
    родителския процес получава информация за
    статуса с който излиза подпроцеса. Процесите се
    подреждат за изпълнение в зависимост от техните
    параметри на приоритета. Тези приоритети се
    управляват от кернелски алгоритми за планиране.
    Потребителите могат да влияят на приоритетите
    като подават параметри <em>nice</em> които изменят
    глобалните приоритети, но все пак трябва да се
    съобразяват със наличните процесорни ресурси в
    зависимост от политиката на планиране на ниво
    ядро.</p>
    <p><strong>Сигнали</strong></p>
    <p>Системата определя набор от сигнали, които може
    да се подават на процес. Сигналите в 4.4BSD се
    моделират след хардуерно прекъсване.. Когато
    сигнал се генерира той се блокира от понататъшно
    появяване докато не бъде обработен <em>(caught)</em>.
    Стандартното действие на сигнал е да прекрати
    процеса, като в някои случаи това е съпроводено с
    създаването на <em>core files</em>, които съдържат копие
    на адресното пространство на процеса.
    Обработката на сигнала може да не е задължителна.
    Той може да се игнорира.<br>
    Някои сигнали неможе да се игнорират. Това са <em>SIGKILL</em>
    който прекратява текущия процес и <em>SIGSTOP</em> който
    регулира работата на процеса.<br>
    Всички сигнали са с еднакъв приоритет. Когато те
    възникват едновременно обработката им зависи от
    конкретната имплементация. Има специални
    механизми които предпазват критични части от
    кода от получаването на някои сигнали. Групи от
    процеси и сесии. За да се осигури контрол над
    много зависими процеси се създават групи от
    процеси - process groups. Групирането на процеси води до
    улеснено изпращане на сигнали до много процеси,
    както и до контролира достъпа до терминали. Има
    методи чрез които да се промени текущата група.
    Създаването на нова група е лесно; стойността на
    новата група е обикновено идентификатора на
    създавания процес.</p>
    <div align="center"><div align="center"><center><table class="t">
      <caption align="left"><b>#ps acux</b></caption>
      <tr>
        <td class="z">USER<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        root<br>
        usera<br>
        root</td>
        <td class="z">PID<br>
        306<br>
        1<br>
        2<br>
        3<br>
        4<br>
        5<br>
        29<br>
        108<br>
        129<br>
        132<br>
        136<br>
        189<br>
        192<br>
        193<br>
        194<br>
        195<br>
        196<br>
        268<br>
        270<br>
        0</td>
        <td class="z">%CPU<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0</td>
        <td class="z">%MEM<br>
        0.1<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.0<br>
        0.2<br>
        0.3<br>
        0.7<br>
        0.6<br>
        0.3<br>
        0.2<br>
        0.2<br>
        0.2<br>
        0.2<br>
        0.2<br>
        0.4<br>
        0.3<br>
        0.0</td>
        <td class="z">VSZ<br>
        08<br>
        528<br>
        0<br>
        0<br>
        0<br>
        0<br>
        208<br>
        916<br>
        952<br>
        2496<br>
        2404<br>
        1336<br>
        924<br>
        924<br>
        924<br>
        924<br>
        924<br>
        1336<br>
        1012<br>
        0</td>
        <td class="z">RSS<br>
        240<br>
        296<br>
        0<br>
        0<br>
        0<br>
        0<br>
        92<br>
        616<br>
        704<br>
        1904<br>
        1436<br>
        896<br>
        616<br>
        616<br>
        616<br>
        616<br>
        616<br>
        940<br>
        860<br>
        0</td>
        <td class="z">TT<br>
        v1<br>
        ??<br>
        ??<br>
        ??<br>
        ??<br>
        ??<br>
        ??<br>
        ??<br>
        ??<br>
        ??<br>
        ??<br>
        v0<br>
        v3<br>
        v4<br>
        v5<br>
        v6<br>
        v7<br>
        v1<br>
        v2<br>
        ??</td>
        <td class="z">STAT<br>
        R+<br>
        ILs<br>
        DL<br>
        DL<br>
        DL<br>
        DL<br>
        Is<br>
        Is<br>
        Is<br>
        Is<br>
        Is+<br>
        Is+<br>
        Is+<br>
        Is+<br>
        Is+<br>
        Is+<br>
        Is+<br>
        Ss<br>
        Is+<br>
        DLs</td>
        <td class="z">STARTED<br>
        4:32PM<br>
        5:50PM<br>
        5:50PM<br>
        5:50PM<br>
        5:50PM<br>
        5:50PM<br>
        5:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        3:50PM<br>
        4:13PM<br>
        4:14PM<br>
        5:50PM</td>
        <td class="z">TIME<br>
        0:00.00<br>
        0:00.00<br>
        0:00.00<br>
        0:00.00<br>
        0:00.00<br>
        0:00.04<br>
        0:00.00<br>
        0:00.05<br>
        0:00.01<br>
        0:00.02<br>
        0:00.28<br>
        0:00.06<br>
        0:00.01<br>
        0:00.01<br>
        0:00.01<br>
        0:00.01<br>
        0:00.01<br>
        0:00.08<br>
        0:00.03<br>
        0:00.00</td>
        <td class="z">COMMAND<br>
        ps<br>
        init<br>
        pagedaemon<br>
        vmdaedom<br>
        bufdaemon<br>
        syncer<br>
        adjkerntz<br>
        syslogd<br>
        cron<br>
        sendmail<br>
        sshd<br>
        csh<br>
        getty<br>
        getty<br>
        getty<br>
        getty<br>
        getty<br>
        csh<br>
        bash<br>
        swapper</td>
      </tr>
    </table>
    </center></div><p align="center"><em>изход от изпълнение на <strong>ps</strong>
    с форматиращи параметри </em></p>
    </div><p>Групите от процеси понякога се определят
    като работа <em>job</em> и се поддържа от програми от
    високо ниво като шела. Терминалите имат
    присвоени идентификатори на групи процеси. Той
    обикновено е еднакъв с групата процеси
    асоциирани с терминала. Шел, контролиращ
    задачите може да създаде групи процеси
    асоциирани с определен терминал, тогава
    терминала става контролиращия терминал на всеки
    процес в групите. Процес може да чете от
    дескриптора на терминал само ако
    идентификаторът му съвпада с този на
    идентификатора на терминала, ако не на процеса се
    забранява да чете от терминала. Като се променя
    идентификатора на групата, терминала може да
    общува с различни задачи.<br>
    Също както процесите се групират в групи от
    процеси, така и групите от процеси се групират в
    сесии <em>(session)</em>. Главното приложение на сесиите
    е да се създаде изолирана среда за демонни
    процеси и техните наследници и да събира логин
    шела на потребителя и задачите, които той
    създава. </p>
    <p><strong>Заключение</strong></p>
    <p>С това приключваме за тази част от
    разглеждането на ядрото. До сега се занимавахме
    само с процесите и въпроси, свързани с
    организацията на ядрото. В следващите статии ще
    разгледаме въпроса за връзките на процесите с
    другите ресурси и между самите тях. </td>
  </tr>
</table>
</body>
</html>
